# -*- coding: utf-8 -*-
"""Algoritmo_Corregir.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WEwrHEEk2v6Eo6Z5bIMzwJRz8tYZvVoI
"""

pip install yfinance

pip install yahoo-finance

pip install yahoofinancials

# Commented out IPython magic to ensure Python compatibility.
# Manipulación y tratamiento de Datos
import numpy as np
import pandas as pd

# Visualización de datos
import plotly.express as px
import matplotlib.pyplot as plt
# %matplotlib inline
plt.style.use('ggplot')

# Modelación Arima
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.graphics.tsaplots import plot_acf,plot_pacf
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller

# Descargar datos de yahoo
import yfinance as yf
from yahoofinancials import YahooFinancials

import statsmodels.api as sm
import statsmodels.tsa.api as smt

from datetime import datetime, timedelta
from timeit import default_timer as timer

# Métrica de Evaluación
from sklearn.metrics import mean_squared_error
from statsmodels.tools.eval_measures import rmse
from sklearn import metrics

# No presentar advertencias
import warnings
warnings.filterwarnings("ignore")

"""## Extracción del Precio del Mercado Seleccionado"""

df = yf.download("GC=F",
                      #start='1992-01-02',
                      start='2022-01-02',
                      end=datetime.now(),
                      progress=False)
df

df = df.drop(["Open"],axis=1)
df = df.drop(["High"],axis=1)
df = df.drop(["Low"],axis=1)
df = df.drop(["Adj Close"],axis=1)
df = df.drop(["Volume"],axis=1)
df

df = df.asfreq(freq = 'D', method = 'ffill')
df

fig = px.line(df, x = df.index, y = df['Close'],template = "plotly_dark", title = "Gráfico de índice seleccionado")
fig.show()

"""## División de Datos para Entenamiento y Prueba"""

train_data = df[:round(len(df) * 0.8)]
test_data = df[round(len(df) * 0.8):]
test = test_data.copy()
train_data.shape, test_data.shape, df.shape

"""## Estandarización de los Datos con la Prueba de Dickey-Fuller Aumentada"""

def Prueba_Dickey_Fuller(precio , nombre_columna):
    print (f'Resultados de la prueba de Dickey-Fuller para columna: {nombre_columna}')
    dftest = adfuller(precio, autolag = 'AIC')
    dfoutput = pd.Series(dftest[0:4], index = ['Test Statistic','p-value','No Lags Used','Número de observaciones utilizadas'])
    for key,value in dftest[4].items():
       dfoutput['Critical Value (%s)' % key] = value
    print (dfoutput)
    if dftest[1] <= 0.05:
        print("Conclusion: ====>")
        print("Rechazar la hipótesis nula")
        print("Los datos son estacionarios")
    else:
        print("Conclusion: ====>")
        print("No se puede rechazar la hipótesis nula")
        print("Los datos no son estacionarios")

Prueba_Dickey_Fuller(df["Close"],"Close")

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()

scaler.fit(train_data)
train_data_escalado = scaler.transform(train_data)
test_data_escalado = scaler.transform(test_data)
test_data_escalado

"""--------------------------PRIMERA FORMA--------------------------"""

from keras.preprocessing.sequence import TimeseriesGenerator
n_input = 1
n_features= 1
generator = TimeseriesGenerator(train_data_escalado, train_data_escalado, length = n_input, batch_size = 1)
generator[1]

from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM

modelo_LSTM = Sequential()
modelo_LSTM.add(LSTM(units = 365, activation = 'relu', input_shape = (n_input, n_features)))
modelo_LSTM.add(Dense(1))
modelo_LSTM.compile(optimizer = 'adam', loss = 'mse')

modelo_LSTM.summary()

modelo_LSTM.fit_generator(generator, epochs = 20)

perdida_LSTM = modelo_LSTM.history.history['loss']
plt.xticks(np.arange(0,21,1))
plt.plot(range(len(perdida_LSTM)),perdida_LSTM);

predicciones_escaladas_LSTM = list()

batch = train_data_escalado[-n_input:]
current_batch = batch.reshape((1, n_input, n_features))

for i in range(len(test_data + 1)):
    prediccion_LSTM = modelo_LSTM.predict(current_batch)[0]
    predicciones_escaladas_LSTM.append(prediccion_LSTM)
    current_batch = np.append(current_batch[:,1:,:],[[prediccion_LSTM]],axis=1)

predicciones_LSTM = scaler.inverse_transform(predicciones_escaladas_LSTM)
predicciones_LSTM

test_data['Predicciones_LSTM'] = predicciones_LSTM
test_data

ai=test_data[["Close","Predicciones_LSTM"]]
fig = px.line(ai, x = test_data.index, y = ai.columns, title = "Predicción con Modelo LSTM", template = "plotly_dark")
fig.show()

